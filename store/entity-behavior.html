<link rel="import" href="../../d2l-fastdom-import/fastdom.html">

<script>
	// 'use strict';

	window.D2L = window.D2L || {};
	window.D2L.PolymerBehaviors = window.D2L.PolymerBehaviors || {};
	window.D2L.PolymerBehaviors.Rubric = window.D2L.PolymerBehaviors.Rubric || {};

	/*
	* Behavior for fetching an entity when an href and token a present
	* @polymerBehavior
	*/
	D2L.PolymerBehaviors.Rubric.EntityBehavior = {
		properties: {
			/**
			 * The href for this siren entity
			 */
			href: {
				type: String,
				reflectToAttribute: true
			},

			/**
			 * The user access token
			 */
			token: {
				type: String,
			},

			/**
			 * The fetched siren entity
			 */
			entity: {
				type: Object,
				value: null,
				notify: true,
				observer: '_onEntityChanged',
			},

			_entityChangedHandler: {
				type: Function,
				value: function() {
					return this._entityChanged.bind(this);
				}
			},

			_alerts: {
				type: Array,
				value: function() { return []; }
			},

			_hasAlerts: {
				type: Boolean,
				value: false
			}
		},

		observers: [
			'_fetchEntity(href, token)'
		],

		ready: function() {
			this._entityChangedHandler = this._entityChanged.bind(this);
		},

		detached: function() {
			if (this.removeListener) {
				this.removeListener();
			}
		},

		_fetchEntity: function(href, token) {
			if (!href || typeof token !== 'string') {
				return;
			}
			if (this.removeListener) {
				this.removeListener();
			}
			this.removeListener = window.D2L.Rubric.EntityStore.addListener(href, token, this._entityChangedHandler);
			var entity = window.D2L.Rubric.EntityStore.fetch(href, token);
			if (entity.status !== 'fetching') {
				// Allows class/mixin to override _entityChanged
				this._entityChanged(entity.entity);
			}
		},

		_entityChanged: function(entity, error) {
			if (!error) {
				this.entity = entity;
				this.fire('d2l-rubric-entity-changed', { entity: entity });
			} else {
				this.fire('d2l-rubric-entity-error', { error: error })
			}
		},

		_onEntityChanged: function(entity, oldEntity) {
			// default empty implementation
		},

		_getSelfLink: function(entity) {
			if (entity) {
				return entity.href || (entity.hasLinkByRel('self') ? entity.getLinkByRel('self').href : '');
			}
			return '';
		},

		_addAlert: function(type, name, message) {
			if (this._alerts) {
				// Something weird happens when clearing alerts immediately before
				// adding alerts and the dom-repeat seems to get stuck and doesn't display
				// new alerts. So adding new alerts async
				setTimeout(function() {
					this.push('_alerts', {
						alertType: type,
						alertName: name,
						alertMessage: message
					});
					// Also trying to set _hasAlerts as a computed property based on _alerts
					// also does not seem to be working reliably so having to manage it manually.
					this._hasAlerts = true;
				}.bind(this));
			}
		},

		_clearAlerts: function() {
			this.splice('_alerts', 0, this._alerts.length);
			this._hasAlerts = false;
		},

		_transitionElement: function(element, maxHeightRem) {
			if (maxHeightRem) {
				fastdom.mutate(function() {
					element.style.maxHeight = maxHeightRem + 'rem';
					element.classList.add('show');
				});
			} else {
				fastdom.mutate(function() {
					element.style.maxHeight = element.offsetHeight + 'px';
					element.classList.remove('show');
				});
			}

			// when the next css transition finishes (which should be the one we just triggered)
			element.addEventListener('transitionend', function(e) {
				// remove this event listener so it only gets triggered once
				element.removeEventListener('transitionend', arguments.callee);

				// remove "max-height" from the element's inline styles, so it can return to its initial value
				fastdom.mutate(function() {
					element.style.maxHeight = null;
				});
			});
		}
	};
</script>
