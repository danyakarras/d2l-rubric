<link rel="import" href="../../d2l-fetch-siren-entity-behavior/d2l-fetch-siren-entity-behavior.html">

<script>
(function() {

	'use strict';

	window.D2L = window.D2L || {};
	window.D2L.Rubric = window.D2L.Rubric || {};

	window.D2L.Rubric.EntityStore = {
		_store: new Map(),

		_listeners: new Map(),

		_invalidationListeners: new Set(),

		_initContainer: function(map, entityId, token, init) {
			const lowerCaseToken = token.toLowerCase();
			const lowerCaseEntityId = entityId.toLowerCase();

			if (!map.has(lowerCaseToken)) {
				map.set(lowerCaseToken, new Map());
			}
			var entityMap = map.get(lowerCaseToken);
			if (init && !entityMap.has(lowerCaseEntityId)) {
				entityMap.set(lowerCaseEntityId, init);
			}
			return entityMap.get(lowerCaseEntityId);
		},

		addListener: function(entityId, token, listener) {

			if (!entityId || typeof token !== 'string' || typeof listener !== 'function') {
				return;
			}

			this._initContainer(this._listeners, entityId, token, new Set()).add(listener);
			return function() {
				this.removeListener(entityId, token, listener);
			}.bind(this);
		},

		addInvalidationListener: function(listener) {
			this._invalidationListeners.add(listener);
		},

		removeInvalidationListener: function(listener) {
			this._invalidationListeners.delete(listener);
		},

		fetch: function(entityId, token, bypassCache) {
			const lowerCaseToken = token.toLowerCase();
			const lowerCaseEntityId = entityId.toLowerCase();

			var entity = this._initContainer(this._store, entityId, token);
			if (!entity || bypassCache) {
				this._store.get(lowerCaseToken).set(lowerCaseEntityId, { 'status': 'fetching', 'entity': null });

				// var headers = new Headers();
				// headers.set('Authorization', `Bearer ${token}`);
				// if (bypassCache) {
				// 	headers.set('pragma', 'no-cache');
				// 	headers.set('cache-control', 'no-cache');
				// }

				// This call is required because FetchSirenEntityBehavior is now
				// assumes it is uses as a true behavior rather than as a 'lib',
				// which is how we were previously using it. Need to revisit.
				D2L.PolymerBehaviors.FetchSirenEntityBehavior.registered();
				D2L.PolymerBehaviors.FetchSirenEntityBehavior._fetchEntityWithToken(
					entityId,
					function() { return Promise.resolve(token); }
				).then(function(entity) {
					this.update(entityId, token, entity);
					if (bypassCache) {
						this._invalidationListeners.forEach(function(listener) {
							listener(entityId, token, entity);
						});
					}
				}.bind(this))
				.catch(function(err) {
					this.setError(entityId, token, err);
				}.bind(this));
			}
			return this._store.get(lowerCaseToken).get(lowerCaseEntityId);
		},

		// This newer version of fetch uses d2l-fetch directly so we can set
		// appropriate headers to bypass caching done by the d2l-fetch middleware chain
		// The intention is to replace the fetch implementation that uses d2l-fetch-siren-entity-behavior with this
		// newer implementation.
		//
		// It is also now returning a promise so that the siren-action-behavior can co-ordinate
		// updating the UI more consistently when dependent entities change as a result of Siren
		// actions.
		fetch2: function(entityId, token, bypassCache) {
			const lowerCaseToken = token.toLowerCase();
			const lowerCaseEntityId = entityId.toLowerCase();

			var entity = this._initContainer(this._store, entityId, token);
			if (!entity || bypassCache) {

				var headers = new Headers();
				headers.set('Authorization', 'Bearer ' + token);

				if (bypassCache) {
					headers.set('pragma', 'no-cache');
					headers.set('cache-control', 'no-cache');
				}

				var request = window.d2lfetch.fetch(entityId, {
					headers: headers
				});
				this._store.get(lowerCaseToken).set(lowerCaseEntityId, {
					status: 'fetching',
					entity: null,
					request: request
				});
				return request.then(function(response) {
					if (response.ok) {
						return response.json();
					}
					return Promise.reject(response.status);
				})
				.then(function(body) {
					var entity = window.D2L.Hypermedia.Siren.Parse(body);
					this.update(entityId, token, entity);
					if (bypassCache) {
						this._invalidationListeners.forEach(function(listener) {
							listener(entityId, token, entity);
						});
					}
					return this._store.get(lowerCaseToken).get(lowerCaseEntityId);
				}.bind(this))
				.catch(function(err) {
					this.setError(entityId, token, err);
					return this._store.get(lowerCaseToken).get(lowerCaseEntityId);
				}.bind(this));
			}

			if (entity.request) {
				return request;
			} else {
				return new Promise(function(resolve) {
					this._notify(lowerCaseEntityId, lowerCaseToken, entity.entity);
					resolve(entity);
				}.bind(this));
			}
		},

		update: function(entityId, token, entity) {
			const lowerCaseToken = token.toLowerCase();
			const lowerCaseEntityId = entityId.toLowerCase();

			this._initContainer(this._store, lowerCaseEntityId, lowerCaseToken);
			return new Promise(function(resolve) {
				const entities = this.expand(entity);
				entities.forEach(function(entity) {
					this._store.get(lowerCaseToken).set(entity.key.toLowerCase(), {
						status: '',
						entity: entity.value,
						request: null
					});
					this._notify(entity.key, token, entity.value);
				}.bind(this));

				resolve(entity);
			}.bind(this));
		},

		expand: function(entity) {
			const entityIndex = new Set();
			const expandEntities = [];
			const entities = [];
			expandEntities.push(entity);

			while (expandEntities.length > 0) {
				const expandEntity = expandEntities.shift();
				(expandEntity.entities || []).forEach(function(entity) {
					expandEntities.push(entity);
				});

				if (!expandEntity.href && expandEntity.hasLinkByRel('self')) {
					const href = expandEntity.getLinkByRel('self').href.toLowerCase();
					if (!entityIndex.has(href)) {
						entityIndex.add(href);
						entities.push({
							key: href,
							value: expandEntity
						});
					}
				}
			}
			return entities;
		},

		setError: function(entityId, token, error) {
			const lowerCaseToken = token.toLowerCase();
			const lowerCaseEntityId = entityId.toLowerCase();

			this._initContainer(this._store, entityId, token);
			return new Promise(function(resolve) {

				this._store.get(lowerCaseToken).set(lowerCaseEntityId, {
					status: 'error',
					entity: null,
					error: error,
					request: null
				});
				this._notifyError(entityId, token, error);

				resolve(error);

			}.bind(this));
		},

		removeListener: function(entityId, token, listener) {

			if (!entityId || typeof token !== 'string' || typeof listener !== 'function' || !this._listeners) {
				return;
			}

			this._initContainer(this._listeners, entityId, token, new Set()).delete(listener);

		},

		_notify: function(entityId, token, entity) {
			const listenerSet = this._initContainer(this._listeners, entityId, token, new Set());
			listenerSet.forEach(function(listener) {
				listener(entity);
			});
		},

		_notifyError: function(entityId, token, error) {
			const listenerSet = this._initContainer(this._listeners, entityId, token, new Set());
			listenerSet.forEach(function(listener) {
				listener(null, error);
			});
		},

		clear: function() {
			this._store = new Map();
			this._listeners = new Map();
			this._invalidationListeners = new Set();
		},

		// parse a Link header
		//
		// Link:<https://example.org/.meta>; rel=meta
		//
		// var r = parseLinkHeader(xhr.getResponseHeader('Link');
		// r['meta'] outputs https://example.org/.meta
		//
		parseLinkHeader: function(links) {
		    var linkexp = /<[^>]*>\s*(\s*;\s*[^\(\)<>@,;:"\/\[\]\?={} \t]+=(([^\(\)<>@,;:"\/\[\]\?={} \t]+)|("[^"]*")))*(,|$)/g;
		    var paramexp = /[^\(\)<>@,;:"\/\[\]\?={} \t]+=(([^\(\)<>@,;:"\/\[\]\?={} \t]+)|("[^"]*"))/g;

		    var matches = links.match(linkexp);
		    var links = [];
		    for (var i = 0; i < matches.length; i++) {
		        var split = matches[i].split('>');
		        var href = split[0].substring(1);
				links.push({
					href: href
				})
		        var ps = split[1];
		        var s = ps.match(paramexp);
		        for (var j = 0; j < s.length; j++) {
		            var p = s[j];
		            var paramsplit = p.split('=');
		            var name = paramsplit[0];
		            var val = paramsplit[1].replace(/["']/g, '');
					if (name === 'rel') {
						var relsplit = val.split(' ');
						links[i][name] = relsplit;
					} else {
						links[i][name] = val;
					}
		        }
		    }
		    return links;
		}
	};
})();

</script>
